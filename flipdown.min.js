/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/flipdown@0.3.2/src/flipdown.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
class FlipDown { constructor(t, e = "flipdown", s = {}) { if ("number" != typeof t) throw new Error(`FlipDown: Constructor expected unix timestamp, got ${typeof t} instead.`); "object" == typeof e && (s = e, e = "flipdown"), this.version = "0.3.2", this.initialised = !1, this.now = this._getTime(), this.epoch = t, this.countdownEnded = !1, this.hasEndedCallback = null, this.element = document.getElementById(e), this.rotors = [], this.rotorLeafFront = [], this.rotorLeafRear = [], this.rotorTops = [], this.rotorBottoms = [], this.countdown = null, this.daysRemaining = 0, this.clockValues = {}, this.clockStrings = {}, this.clockValuesAsString = [], this.prevClockValuesAsString = [], this.opts = this._parseOptions(s), this._setOptions(), console.log(`FlipDown ${this.version} (Theme: ${this.opts.theme})`) } start() { return this.initialised || this._init(), this.countdown = setInterval(this._tick.bind(this), 1e3), this } ifEnded(t) { return this.hasEndedCallback = function () { t(), this.hasEndedCallback = null }, this } _getTime() { return (new Date).getTime() / 1e3 } _hasCountdownEnded() { return this.epoch - this.now < 0 ? (this.countdownEnded = !0, null != this.hasEndedCallback && (this.hasEndedCallback(), this.hasEndedCallback = null), !0) : (this.countdownEnded = !1, !1) } _parseOptions(t) { let e = ["Days", "Hours", "Minutes", "Seconds"]; return t.headings && 4 === t.headings.length && (e = t.headings), { theme: t.hasOwnProperty("theme") ? t.theme : "dark", headings: e } } _setOptions() { this.element.classList.add(`flipdown__theme-${this.opts.theme}`) } _init() { this.initialised = !0, this._hasCountdownEnded() ? this.daysremaining = 0 : this.daysremaining = Math.floor((this.epoch - this.now) / 86400).toString().length; for (var t = this.daysremaining <= 2 ? 2 : this.daysremaining, e = 0; e < t + 6; e++)this.rotors.push(this._createRotor(0)); var s = []; for (e = 0; e < t; e++)s.push(this.rotors[e]); this.element.appendChild(this._createRotorGroup(s, 0)); var o = t; for (e = 0; e < 3; e++) { for (var i = [], r = 0; r < 2; r++)i.push(this.rotors[o]), o++; this.element.appendChild(this._createRotorGroup(i, e + 1)) } return this.rotorLeafFront = Array.prototype.slice.call(this.element.getElementsByClassName("rotor-leaf-front")), this.rotorLeafRear = Array.prototype.slice.call(this.element.getElementsByClassName("rotor-leaf-rear")), this.rotorTop = Array.prototype.slice.call(this.element.getElementsByClassName("rotor-top")), this.rotorBottom = Array.prototype.slice.call(this.element.getElementsByClassName("rotor-bottom")), this._tick(), this._updateClockValues(!0), this } _createRotorGroup(t, e) { var s = document.createElement("div"); s.className = "rotor-group"; var o = document.createElement("div"); return o.className = "rotor-group-heading", o.setAttribute("data-before", this.opts.headings[e]), s.appendChild(o), appendChildren(s, t), s } _createRotor(t = 0) { var e = document.createElement("div"), s = document.createElement("div"), o = document.createElement("figure"), i = document.createElement("figure"), r = document.createElement("div"), n = document.createElement("div"); return e.className = "rotor", s.className = "rotor-leaf", o.className = "rotor-leaf-rear", i.className = "rotor-leaf-front", r.className = "rotor-top", n.className = "rotor-bottom", o.textContent = t, r.textContent = t, n.textContent = t, appendChildren(e, [s, r, n]), appendChildren(s, [o, i]), e } _tick() { this.now = this._getTime(); var t = this.epoch - this.now <= 0 ? 0 : this.epoch - this.now; this.clockValues.d = Math.floor(t / 86400), t -= 86400 * this.clockValues.d, this.clockValues.h = Math.floor(t / 3600), t -= 3600 * this.clockValues.h, this.clockValues.m = Math.floor(t / 60), t -= 60 * this.clockValues.m, this.clockValues.s = Math.floor(t), this._updateClockValues(), this._hasCountdownEnded() } _updateClockValues(t = !1) { function e() { this.rotorTop.forEach((t, e) => { t.textContent != this.clockValuesAsString[e] && (t.textContent = this.clockValuesAsString[e]) }) } function s() { this.rotorLeafRear.forEach((t, e) => { if (t.textContent != this.clockValuesAsString[e]) { t.textContent = this.clockValuesAsString[e], t.parentElement.classList.add("flipped"); var s = setInterval(function () { t.parentElement.classList.remove("flipped"), clearInterval(s) }.bind(this), 500) } }) } this.clockStrings.d = pad(this.clockValues.d, 2), this.clockStrings.h = pad(this.clockValues.h, 2), this.clockStrings.m = pad(this.clockValues.m, 2), this.clockStrings.s = pad(this.clockValues.s, 2), this.clockValuesAsString = (this.clockStrings.d + this.clockStrings.h + this.clockStrings.m + this.clockStrings.s).split(""), this.rotorLeafFront.forEach((t, e) => { t.textContent = this.prevClockValuesAsString[e] }), this.rotorBottom.forEach((t, e) => { t.textContent = this.prevClockValuesAsString[e] }), t ? (e.call(this), s.call(this)) : (setTimeout(e.bind(this), 500), setTimeout(s.bind(this), 500)), this.prevClockValuesAsString = this.clockValuesAsString } } function pad(t, e) { return (t = t.toString()).length < e ? pad("0" + t, e) : t } function appendChildren(t, e) { e.forEach(e => { t.appendChild(e) }) }
//# sourceMappingURL=/sm/a707cda7f8b6997a7a2c15ec1eace57c9f3bbd9d1434a760963cb96c52083089.map